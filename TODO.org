* CORE
** DONE move tracking logic to core
CLOSED: [2026-01-11 Sun 20:43]
** DONE implemenT shallow builds
CLOSED: [2026-01-06 Tue 20:44]
** DONE implement partial builds
CLOSED: [2026-01-07 Wed 14:02]
** DONE KILL consider using HashSet for build/nodes and build/links 
CLOSED: [2026-01-06 Tue 13:46]
** DONE Consider separating link and frontmatter gathering from compilation, to avoid double compilation
CLOSED: [2026-01-06 Tue 13:45]
Easy solution:
- shallow build has a "compile" argument
- regular "incremental" builds from lsp, etc. WILL compile
- full builds will NOT compile. just resolve all nodes and links, then at the end compile all files (in parallel?)
** DONE separate typst build logic
CLOSED: [2026-01-06 Tue 14:07]
** DONE fix typst::compile outputting empty files

CLOSED: [2026-01-07 Wed 18:28]
this is actually intended behaviour, as the files with the ghost links are never built, and thus their links are never added
** DONE add FULL CLI build
CLOSED: [2026-01-07 Wed 21:19]
** DONE speed up full builds
CLOSED: [2026-01-07 Wed 23:43]
** DONE make full build take less (eg. parallel compiles, incremental compiles...)
CLOSED: [2026-01-07 Wed 23:43]
** DONE use https://github.com/ParkMyCar/compact_str for IDs
CLOSED: [2026-01-07 Wed 23:54]
** TODO remove dangling nodes (exist in build but not in user db) BEFORE a full build
* LSP
** DONE keep document synchronized
CLOSED: [2026-01-08 Thu 18:33]
** DONE when opening a file, find its root, and check if it has a project
CLOSED: [2026-01-08 Thu 21:30]
if it does, then load the project, and keep it in a dashmap.
for files that DO NOT have a project associated, just ignore their requests.
** DONE when loading a project, load all data associated with it (config, nodes, build/nodes, build/links)
CLOSED: [2026-01-08 Thu 21:30]
** DONE watch for changes on all omni related files, and in that case mutate the Project
CLOSED: [2026-01-09 Fri 20:57]
** DONE switch to tracing instead of log
CLOSED: [2026-01-10 Sat 13:12]
** DONE Add link completion
CLOSED: [2026-01-10 Sat 21:53]
** DONE instead of breaking the whole completion, just remove problematic entries
CLOSED: [2026-01-10 Sat 22:26]
** DONE add functuon to get link under cursor
CLOSED: [2026-01-11 Sun 16:20]
** DONE Add Hover
CLOSED: [2026-01-11 Sun 16:20]
hovering over a link will show a preview of the referenced file.
** DONE Add link go to definition
CLOSED: [2026-01-11 Sun 16:54]
** DONE Add code action to pretty much run ~new~
CLOSED: [2026-01-11 Sun 19:27]
(apply template, track, and run partial build)
** DONE Separate apply template and track
CLOSED: [2026-01-11 Sun 20:55]
- code action like "Apply template `note` and track"
  - applies an edit, containing the whole template
  - executes a "track" command which just adds the node to nodes.toml
- code action like "Build"
  - builds the file and then says "done"
** TODO add BUILD code action
** TODO Add link go to references 
** TODO Listen to LSP file renames/moves
** TODO switch to LSP client for file watching
https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_didChangeWatchedFiles
* TYPST PLUGIN
** DONE make the links show the title of the node
CLOSED: [2026-01-08 Thu 00:47]
** DONE show something for ghost links
CLOSED: [2026-01-08 Thu 00:47]
** TODO make the links actually point to something (when we have SSG?)

* CLI
** DONE what to do with ~src~?
CLOSED: [2026-01-04 Sun 13:25]
now that we have the OmniPath stuff, it's easier to just add src when pathizing?
or should i abandon it?
** DONE main should find the project root instead of just finding omni.toml
CLOSED: [2026-01-04 Sun 00:43]
** DONE give the project root to commands
CLOSED: [2026-01-04 Sun 01:04]
** DONE consider using ~camino~ for Utf8Paths
CLOSED: [2026-01-04 Sun 01:59]
** DONE add ~new~ command to CLI
CLOSED: [2026-01-04 Sun 16:02]
** DONE check if target in ~new~ is within the notes prefix
CLOSED: [2026-01-04 Sun 14:00]
** DONE add ~slug~ package
CLOSED: [2026-01-04 Sun 01:59]
** DONE define a project structure
CLOSED: [2026-01-02 Fri 01:49]
- project
  - nodes.toml
  - omni.toml
  - resources/
    - typst/
        - lib/
            - omni.typ <typst module>
            - omniscience_typst.wasm <typst plugin>
        - templates/ <typst templates>
            - note.typ
    - templates/ <omni templates>
        - note.typ // we also might use tera to pass user arbitrary arguments to templates. like "omni new note --title mytitle"
        - note_md.md
        - blog.md
        - todo.org
  - build/
    - nodes.toml
    - links.toml
    - <all compiled files>
  - assets/
    - <users static assets>
** TODO make it so that init templates are loaded and usable even when not in the rust project's directory. using include_dir or something
** DONE the new command should perhaps also add it's new node to build/nodes.toml 
CLOSED: [2026-01-07 Wed 23:54]
and do a "partial build", to resolve some ghost links that might have existed to that node.
partial build would also be useful for LSP later on.
** DONE fix all IDs ending in 01 
CLOSED: [2026-01-04 Sun 22:44]
** DONE fix possible edge case where multiple nodes are created at once, adn they all have the same id
CLOSED: [2026-01-04 Sun 22:44]
** TODO consider removing is_already_tracked from just_track and let callers sort it out
** DONE Add a ~private~ property to nodes
CLOSED: [2026-01-08 Thu 00:07]
** TODO install shell completions with clap completions

** TODO add a ~clean~ command that resets ~build/~
** TODO add a ~--clean~ flag to ~build~
* Tasks
** DONE Write a function to resolve any kind of link
** DONE test said function
CLOSED: [2025-12-27 Sat 18:02]
** DONE consider using ~Cow~ for ~Id~...
CLOSED: [2025-12-27 Sat 18:12]
** DONE write a function that can take a raw filepart, headingpart and alias
CLOSED: [2025-12-29 Mon 22:58]
** TODO write a function to normalize a typst link based on the target platform
- if target == "pdf" then pretty much change the extension from .typ to .pdf and add file://
- if target == "url" then pretty much remove the extension
** DONE Write a WASM plugin that normalizes Typst links 
CLOSED: [2025-12-31 Wed 15:49]
- Typst-compile time:
  - take the omnilinks and try to get the ~To~ part (id, file title etc.)
  - add a #metadata for each link
  - omni cli is gonna later on pick up all metadata from typst query to *gather* the links  
** DONE add title to nodes
CLOSED: [2026-01-04 Sun 02:14]
** TODO figure out how to use heading part in wasm pklugin
** TODO Pdf links?
pdf is a bit fussy about links.
while in html we can just use a / and it will be a "relative" link, 
in PDF we (theoretically) need a full URL.
AND it looks like firefox doesn't even like ~file://~ urls.
we could solve this by:
- force users to have a omni_machine.toml file with machine specific settings (to be gitignored)
- the file contains the prepend URL for all links.
- each node has a SINGLE url associated with it.
- with ~?format=pdf~ we can see a PDF embedded inside the website for easy navigation.

it's a bit of a dirty solution but ay that's what you have to do
** INFO a way to "smuggle" outside data into typst... might be useful eg. for making sure a typst file knows what it is
The sys.inputs dictionary, which makes external inputs available to the project. 
An input specified in the command line as --input key=value becomes available under sys.inputs.key as "value".
To include spaces in the value, it may be enclosed with single or double quotes.

MIGHT not play well with tinymist though.
* Thinking
** DONE define a config file "omni.toml" that counts as project root
CLOSED: [2025-12-26 Fri 17:09]
keys:
- project name
- directory aliases
- (user) nodes_path = nodes.toml
- db_path = db.csv (??)
  (db.csv is the ultimate source of truth for linking.)
    * DONE choose a database format (csv, toml, json...)
CLOSED: [2025-12-26 Fri 17:10]
settled on toml
** DONE what do we even want to store in the db?
CLOSED: [2025-12-27 Sat 03:14]
+ i'm in a directory called ~notes~
+ ~omni new "My Note.typ"~
+ recognize format ~.typ~. go get the template and everything...
+ creates file ~notes/My Note.typ~
+ database gets a new entry with an ~id~ as key:
  + filename (which may later change!)
  + aliases (should aliases be here? maybe useful for typsting..)
    + one of these aliases is the slug: ~my-note~
  + other metadata such as format, kind of LOCATION (note, directory, heading in other note..)
    
#+BEGIN_SRC typst
@omni.matrix:operations.addition // to full heading path slug [[omni:matrix/operations/addition]]
@omni.matrix:addition // to typst label (which acts as alias for heading) OR heading slug [[omni:matrix#addition]]
@omni.matrix // to file [[omni:matrix]]
@omni.linear-algebra.matrix // to file /Linear Algebra/matrix
@omni.linalg.matrix // to file /Linear Algebra/matrix (WITH AN ALIAS DEFINED IN omni.toml)
@omni.matrix[matrices] // to file with alias [[omni:matrix|matrices]]
#+END_SRC

think about how files can be linked to:
- by slug: ~@omni.my-note~ = ask db => my-note is an alias given to "12bfec" => "notes/my-note.typ"
- by absolute path: ~@omni.linalg.my-note~ = "notes/linalg/my-note"
- by absolute id: ~@omni.a5ebfe~ = go through db => "notes/my-note"
  
  WE SHOULD THEN HAVE TWO DB's: A USER MODIFIABLE ONE, AND A DYNAMIC DB BUILT FROM THE USER FACING ONE AND ALL OTHER DATA GATHERED.
** DONE perhaps look into how zettelkasten id's should work.
CLOSED: [2025-12-27 Sat 14:21]
each file (node) has it's own ID. the file might move, but it's ID remains the same.
i personally don't like links with ID's as it makes the file hard to read.
but it might be supported as a "link style" setting for the lsp, where you type the text for a link, 
and it then fills in the id with an alias.

Think about it: when someone renames (~mv~) a file, i have two problems:
that file becomes "untracked",Â as it is no longer present within ~nodes.toml~.
The LSP client might inform us when we move a file. (by the way snacks.rename does that in nvim)
Then we may also have a mv wrapper in the CLI that manages updating the db and updating links in other files.
(the wrapper may also use our dir_aliases..)
like ~omni mv linalg/matrix.typ math/matrix.typ~
would first of all update ~nodes.toml~, and all links of form ~path.file~ to that node.
The LSP would do the same thing. Check this out..
[[https://github.com/folke/snacks.nvim/blob/main/docs/rename.md]]
** DONE figure out how links are resolved
CLOSED: [2026-01-08 Thu 11:48]
eg. Typst links are divided in four parts:
1. ~@omni~ preamble
2. ~.<filename>~ | ~.<path>.<filename>~ File
3. ~.<path_to_heading>.<heading>~ | ~:<heading>~ Heading/label (optional)
4. ~[<alias>]~ (optional)
   
Say our starting situation is:
#+begin_src
notes/
  cs/ 
    c/
      matrix.md
    discrete-math/
      proofs/
        proof-by-induction.typ
    linear-algebra/
      matrix.typ
    overview.md
  omni.toml
#+end_src

and ~db.toml~ is:
#+begin_src toml
[node.id1]
path = "cs/c/matrix.md"
kind = "file"
names = ["matrix"]

[node.id2]
path = "cs/discrete-math/proofs/proof-by-induction.typ"
kind = "file"
names = ["proof-by-induction", "induction"]

[node.id3]
path = "cs/linear-algebra/matrix.typ"
kind = "file"
names = ["matrix", "matrices"]

[node.id4]
path = "cs/overview.md"
kind = "file"
names = ["overview"]
#+end_src

So say we have a link like: ~@omni.matrix:addition[Matrix Addition]~
0. recognize that it is actually an omni link by the @omni tag. and it is of the form: ~name:heading[alias]~
1. ok, the name provided is ~matrix~. go read the .db.toml and find the id related to the name ="matrix"=
2. we have a conflict: we have two files with name "matrix". 
   that in itself is not a problem, but referring with just ~matrix~ is wrong,
   and will result in an error, with a hint suggesting to use a path.
   
Next: ~@omni.matrices~
0. the link is of form ~name~
1. now search the name ~matrices~ in nodes 
2. final resolved link =linear-algebra/matrix.typ=
   
Next: ~@omni.linalg.matrix:addition~
0. the link is of form ~path.name:heading~
1. check ~Config.dir_aliases~. ~linalg~ -> ~"cs/linear-algebra"~
2. Alright, now search the name ~matrix~ in nodes where the path *starts with* ~linear-algebra~ 
   (so it will ignore ~c~)
3. Now, what is the hierarchy of ~addition~?
   - it's typst, it might just be a label. Is it? yes, just return ~addition~
4. final resolved link =linear-algebra/matrix.typ#addition=
   
Next: ~@omni.cs.discrete-math.proof-by-induction~
0. the link is of form ~path.name~
1. ~cs~ and ~discrete-math~ are not aliases, so the path resolves to ~cs/discrete-math~
2. find the node in the db with name ~proof-by-induction~ where path *starts with* ~cs/discrete-math~
3. final resolved link =cs/discrete-math/proofs/proof-by-induction=
   
Next: ~@omni-id.id2~
0. the link is of form ~id~
1. final resolved link =cs/c/matrix.md=
   
Next: ~@omni.dima.proofs.induction:other.strong-induction~ \equiv ~[[omni:dima/proofs/induction#other#strong-induction]]~
0. the link is of form ~path.name:heading_path.heading~
1. check ~Config.dir_aliases~. ~dima~ -> ~"cs/discrete-math"~
2. append ~proofs~ to the dir to get ~cs/discrete-math/proofs~
3. Alright, now search the name ~induction~ in nodes where the path *starts with* ~cs/discrete-math/proofs~ 
4. now for the heading path. it's ~#other#strong-induction~. 
   in typst, you should really use labels for this. but this would also match
   #+begin_src typ
   = Other <other>
   == Strong Induction <strong>
   #+end_src
   But it wuld be best to use ~#strong~ or ~#other#strong~.
   The header paths are mostly for obsidian wikilinks as those support it.
   Pretty much in typst, headings correspond either to labels or a slug-ized version of the real heading.
   OR we could force every heading to have a label...
5. final resolved link =cs/discrete-math/proofs/proof-by-induction.typ#other#strong-induction=
   and this is kind of what it would look like internally if it had an alias:
   #+begin_src toml
  from = "id3"
  to = "id2"
  heading_path = "#other#strong-induction"
  alias = "prove by strong induction"
   #+end_src

FINAL STEP:
all links must be normalized before using in html.
1. Check if the link resolves to any location.
   - Yes -> proceed
   - No  -> stop here and display a gray link that points to nothing.
2. url's want a single ~#id~ hash thing. so ~#operations#addition~ becomes ~#addition~
   (KEEP IN MIND: if we have two different headings called addition, the html link will point to the first one it finds.
   no big deal, that's what it does in obsidian too. we could also throw an error in that case.)
** DONE consider abandoning the id-ization for headings, can complicate things a lot
CLOSED: [2025-12-26 Fri 21:15]
We also need to keep in mind how org-roam works. there you can assign an ID any "subtree" 
but that's something we only need to keep in mind for building the links.toml. 
which in that case we might ask org-roam itself for it's internal links
** TODO are we sure that we need the ~heading_path.heading~?
because in typst we can just use labels for this.
but it might be useful for other formats, so i guess we should keep it?
** DONE look into WASM for writing a function for resolving links that typst can use too
CLOSED: [2025-12-28 Sun 13:49]
** TODO How to gather links
- [ ] Typst
  - [ ] Normalize at typst-compile time AND add links as #metadata (with WASM)
  - [ ] Gather at omni-build time (with typst query)
- [ ] Markdown
  - [ ] Normalize and gather at omni-build time 
    - [ ] via a markdown-rs extension 
    - [ ] OR by inspecting the AST with the default wiki links extension 
    - [ ] OR just use pulldown-cmark
  - [ ] Keep in mind that we also have to parse regular wiki links and even regular md links.
- [ ] Org
  - [ ] Similar to markdown but different libraries.
** TODO lsp needs the ghost links for completions too.
